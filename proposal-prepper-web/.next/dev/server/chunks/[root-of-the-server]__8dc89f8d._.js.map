{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":["file:///Users/afos/Downloads/CtrlCheck-af-nonopen/proposal-prepper-services/src/mock-api-server.ts"],"sourcesContent":["/*\n * SPDX-License-Identifier: AGPL-3.0-or-later\n * SPDX-FileCopyrightText: 2025 Seventeen Sierra LLC\n */\n\nimport type {\n  AnalysisSessionResponse,\n  ApiResponse,\n  ComplianceIssue,\n  ComplianceResultsResponse,\n  UploadSessionResponse,\n} from './ai-router-client';\n\n/**\n * Framework-Independent Mock API Server\n *\n * Provides mock API functionality that can be used with any framework\n * or as a standalone server. Extracted from Next.js API routes for\n * maximum portability and reusability.\n */\nexport class MockApiServer {\n  private mockDelay: number;\n\n  constructor(mockDelay = 1000) {\n    this.mockDelay = mockDelay;\n  }\n\n  private async simulateDelay(customDelay?: number): Promise<void> {\n    const delay = customDelay ?? this.mockDelay;\n    return new Promise((resolve) => setTimeout(resolve, delay));\n  }\n\n  /**\n   * Handle document upload\n   * Extracted from src/app/api/documents/upload/route.ts\n   */\n  async handleDocumentUpload(file: File): Promise<ApiResponse<UploadSessionResponse>> {\n    try {\n      // Validate file presence\n      if (!file) {\n        return {\n          success: false,\n          error: 'No file provided',\n          code: 'MISSING_FILE',\n        };\n      }\n\n      // Validate file type\n      if (file.type !== 'application/pdf') {\n        return {\n          success: false,\n          error: 'Only PDF files are accepted',\n          code: 'INVALID_FILE_TYPE',\n        };\n      }\n\n      // Validate file size (100MB limit)\n      if (file.size > 100 * 1024 * 1024) {\n        return {\n          success: false,\n          error: 'File size exceeds 100MB limit',\n          code: 'FILE_TOO_LARGE',\n        };\n      }\n\n      // Simulate processing delay\n      await this.simulateDelay();\n\n      // Generate mock upload session\n      const uploadSession: UploadSessionResponse = {\n        id: `upload_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`,\n        filename: file.name,\n        fileSize: file.size,\n        mimeType: file.type,\n        status: 'completed',\n        progress: 100,\n        startedAt: new Date().toISOString(),\n        completedAt: new Date().toISOString(),\n      };\n\n      return {\n        success: true,\n        data: uploadSession,\n      };\n    } catch (error) {\n      console.error('Upload error:', error);\n      return {\n        success: false,\n        error: 'Upload failed',\n        code: 'UPLOAD_FAILED',\n      };\n    }\n  }\n\n  /**\n   * Handle analysis start\n   * Extracted from src/app/api/analysis/start/route.ts\n   */\n  async handleAnalysisStart(proposalId: string): Promise<ApiResponse<AnalysisSessionResponse>> {\n    try {\n      if (!proposalId) {\n        return {\n          success: false,\n          error: 'Proposal ID is required',\n          code: 'MISSING_PROPOSAL_ID',\n        };\n      }\n\n      // Simulate processing delay\n      await this.simulateDelay(500);\n\n      // Generate mock analysis session\n      const analysisSession: AnalysisSessionResponse = {\n        id: `analysis_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`,\n        proposalId,\n        status: 'analyzing',\n        progress: 0,\n        startedAt: new Date().toISOString(),\n        estimatedCompletion: new Date(Date.now() + 30000).toISOString(), // 30 seconds from now\n        currentStep: 'Starting compliance analysis...',\n      };\n\n      return {\n        success: true,\n        data: analysisSession,\n      };\n    } catch (error) {\n      console.error('Analysis start error:', error);\n      return {\n        success: false,\n        error: 'Failed to start analysis',\n        code: 'ANALYSIS_START_FAILED',\n      };\n    }\n  }\n\n  /**\n   * Handle analysis results retrieval\n   * Extracted from src/app/api/analysis/[sessionId]/results/route.ts\n   */\n  async handleAnalysisResults(sessionId: string): Promise<ApiResponse<ComplianceResultsResponse>> {\n    try {\n      if (!sessionId) {\n        return {\n          success: false,\n          error: 'Session ID is required',\n          code: 'MISSING_SESSION_ID',\n        };\n      }\n\n      // Simulate processing delay\n      await this.simulateDelay(500);\n\n      // Generate mock compliance issues with proper structure\n      const mockIssues: ComplianceIssue[] = [\n        {\n          id: 'issue_1',\n          severity: 'warning',\n          title: 'Budget Justification Format',\n          description:\n            'Budget justification follows standard format but could include more detail on equipment costs',\n          location: {\n            page: 8,\n            section: 'Budget Justification',\n            text: 'Equipment costs section',\n          },\n          regulation: {\n            framework: 'FAR',\n            section: '15.204-5',\n            reference: 'FAR 15.204-5 - Budget Justification Requirements',\n          },\n          remediation: 'Consider adding more detailed breakdown of equipment and personnel costs',\n        },\n        {\n          id: 'issue_2',\n          severity: 'info',\n          title: 'Data Management Plan',\n          description: 'Data management plan is present and meets basic requirements',\n          location: {\n            page: 15,\n            section: 'Data Management Plan',\n            text: 'Data management section',\n          },\n          regulation: {\n            framework: 'FAR',\n            section: '19-069',\n            reference: 'NSF 19-069 - Data Management Plan Requirements',\n          },\n          remediation: 'Plan is compliant with current requirements',\n        },\n      ];\n\n      // Randomly include issues (70% chance)\n      const issues = Math.random() > 0.3 ? mockIssues : [];\n\n      // Generate mock analysis results\n      const analysisResults: ComplianceResultsResponse = {\n        id: sessionId,\n        proposalId: `proposal_${sessionId}`,\n        status: issues.length === 0 ? 'pass' : 'warning',\n        issues,\n        summary: {\n          totalIssues: issues.length,\n          criticalIssues: issues.filter((i) => i.severity === 'critical').length,\n          warningIssues: issues.filter((i) => i.severity === 'warning').length,\n        },\n        generatedAt: new Date().toISOString(),\n      };\n\n      return {\n        success: true,\n        data: analysisResults,\n      };\n    } catch (error) {\n      console.error('Results retrieval error:', error);\n      return {\n        success: false,\n        error: 'Failed to retrieve results',\n        code: 'RESULTS_RETRIEVAL_FAILED',\n      };\n    }\n  }\n\n  /**\n   * Handle upload status check\n   */\n  async handleUploadStatus(sessionId: string): Promise<ApiResponse<UploadSessionResponse>> {\n    try {\n      if (!sessionId) {\n        return {\n          success: false,\n          error: 'Session ID is required',\n          code: 'MISSING_SESSION_ID',\n        };\n      }\n\n      await this.simulateDelay(200);\n\n      const uploadSession: UploadSessionResponse = {\n        id: sessionId,\n        filename: 'mock-proposal.pdf',\n        fileSize: 1024000,\n        mimeType: 'application/pdf',\n        status: 'completed',\n        progress: 100,\n        startedAt: new Date(Date.now() - 10000).toISOString(),\n        completedAt: new Date().toISOString(),\n      };\n\n      return {\n        success: true,\n        data: uploadSession,\n      };\n    } catch (error) {\n      console.error('Upload status error:', error);\n      return {\n        success: false,\n        error: 'Failed to get upload status',\n        code: 'UPLOAD_STATUS_FAILED',\n      };\n    }\n  }\n\n  /**\n   * Handle analysis status check\n   */\n  async handleAnalysisStatus(sessionId: string): Promise<ApiResponse<AnalysisSessionResponse>> {\n    try {\n      if (!sessionId) {\n        return {\n          success: false,\n          error: 'Session ID is required',\n          code: 'MISSING_SESSION_ID',\n        };\n      }\n\n      await this.simulateDelay(300);\n\n      const analysisSession: AnalysisSessionResponse = {\n        id: sessionId,\n        proposalId: `proposal_${sessionId}`,\n        status: 'completed',\n        progress: 100,\n        startedAt: new Date(Date.now() - 30000).toISOString(),\n        completedAt: new Date().toISOString(),\n        currentStep: 'Analysis completed',\n      };\n\n      return {\n        success: true,\n        data: analysisSession,\n      };\n    } catch (error) {\n      console.error('Analysis status error:', error);\n      return {\n        success: false,\n        error: 'Failed to get analysis status',\n        code: 'ANALYSIS_STATUS_FAILED',\n      };\n    }\n  }\n\n  /**\n   * Health check endpoint\n   */\n  async handleHealthCheck(): Promise<\n    ApiResponse<{ status: string; version: string; timestamp: string }>\n  > {\n    await this.simulateDelay(100);\n\n    return {\n      success: true,\n      data: {\n        status: 'healthy',\n        version: '1.0.0-mock',\n        timestamp: new Date().toISOString(),\n      },\n    };\n  }\n\n  /**\n   * Get issue details\n   */\n  async handleIssueDetails(issueId: string): Promise<ApiResponse<ComplianceIssue>> {\n    try {\n      if (!issueId) {\n        return {\n          success: false,\n          error: 'Issue ID is required',\n          code: 'MISSING_ISSUE_ID',\n        };\n      }\n\n      await this.simulateDelay(200);\n\n      const issue: ComplianceIssue = {\n        id: issueId,\n        severity: 'warning',\n        title: 'Sample Compliance Issue',\n        description:\n          'This is a detailed description of the compliance issue found in the document.',\n        location: {\n          page: 5,\n          section: 'Technical Approach',\n          text: 'Relevant text excerpt from the document',\n        },\n        regulation: {\n          framework: 'FAR',\n          section: '52.204-8',\n          reference: 'FAR 52.204-8 - Annual Representations and Certifications',\n        },\n        remediation: 'Recommended steps to address this compliance issue.',\n      };\n\n      return {\n        success: true,\n        data: issue,\n      };\n    } catch (error) {\n      console.error('Issue details error:', error);\n      return {\n        success: false,\n        error: 'Failed to get issue details',\n        code: 'ISSUE_DETAILS_FAILED',\n      };\n    }\n  }\n}\n\n/**\n * Default mock API server instance\n */\nexport const mockApiServer = new MockApiServer();\n"],"names":[],"mappings":"AAAA;;;CAGC;;;;;;AAiBM,MAAM;IACH,UAAkB;IAE1B,YAAY,YAAY,IAAI,CAAE;QAC5B,IAAI,CAAC,SAAS,GAAG;IACnB;IAEA,MAAc,cAAc,WAAoB,EAAiB;QAC/D,MAAM,QAAQ,eAAe,IAAI,CAAC,SAAS;QAC3C,OAAO,IAAI,QAAQ,CAAC,UAAY,WAAW,SAAS;IACtD;IAEA;;;GAGC,GACD,MAAM,qBAAqB,IAAU,EAA+C;QAClF,IAAI;YACF,yBAAyB;YACzB,IAAI,CAAC,MAAM;gBACT,OAAO;oBACL,SAAS;oBACT,OAAO;oBACP,MAAM;gBACR;YACF;YAEA,qBAAqB;YACrB,IAAI,KAAK,IAAI,KAAK,mBAAmB;gBACnC,OAAO;oBACL,SAAS;oBACT,OAAO;oBACP,MAAM;gBACR;YACF;YAEA,mCAAmC;YACnC,IAAI,KAAK,IAAI,GAAG,MAAM,OAAO,MAAM;gBACjC,OAAO;oBACL,SAAS;oBACT,OAAO;oBACP,MAAM;gBACR;YACF;YAEA,4BAA4B;YAC5B,MAAM,IAAI,CAAC,aAAa;YAExB,+BAA+B;YAC/B,MAAM,gBAAuC;gBAC3C,IAAI,CAAC,OAAO,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,KAAK;gBACzE,UAAU,KAAK,IAAI;gBACnB,UAAU,KAAK,IAAI;gBACnB,UAAU,KAAK,IAAI;gBACnB,QAAQ;gBACR,UAAU;gBACV,WAAW,IAAI,OAAO,WAAW;gBACjC,aAAa,IAAI,OAAO,WAAW;YACrC;YAEA,OAAO;gBACL,SAAS;gBACT,MAAM;YACR;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,iBAAiB;YAC/B,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,MAAM;YACR;QACF;IACF;IAEA;;;GAGC,GACD,MAAM,oBAAoB,UAAkB,EAAiD;QAC3F,IAAI;YACF,IAAI,CAAC,YAAY;gBACf,OAAO;oBACL,SAAS;oBACT,OAAO;oBACP,MAAM;gBACR;YACF;YAEA,4BAA4B;YAC5B,MAAM,IAAI,CAAC,aAAa,CAAC;YAEzB,iCAAiC;YACjC,MAAM,kBAA2C;gBAC/C,IAAI,CAAC,SAAS,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,SAAS,CAAC,GAAG,KAAK;gBAC3E;gBACA,QAAQ;gBACR,UAAU;gBACV,WAAW,IAAI,OAAO,WAAW;gBACjC,qBAAqB,IAAI,KAAK,KAAK,GAAG,KAAK,OAAO,WAAW;gBAC7D,aAAa;YACf;YAEA,OAAO;gBACL,SAAS;gBACT,MAAM;YACR;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,yBAAyB;YACvC,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,MAAM;YACR;QACF;IACF;IAEA;;;GAGC,GACD,MAAM,sBAAsB,SAAiB,EAAmD;QAC9F,IAAI;YACF,IAAI,CAAC,WAAW;gBACd,OAAO;oBACL,SAAS;oBACT,OAAO;oBACP,MAAM;gBACR;YACF;YAEA,4BAA4B;YAC5B,MAAM,IAAI,CAAC,aAAa,CAAC;YAEzB,wDAAwD;YACxD,MAAM,aAAgC;gBACpC;oBACE,IAAI;oBACJ,UAAU;oBACV,OAAO;oBACP,aACE;oBACF,UAAU;wBACR,MAAM;wBACN,SAAS;wBACT,MAAM;oBACR;oBACA,YAAY;wBACV,WAAW;wBACX,SAAS;wBACT,WAAW;oBACb;oBACA,aAAa;gBACf;gBACA;oBACE,IAAI;oBACJ,UAAU;oBACV,OAAO;oBACP,aAAa;oBACb,UAAU;wBACR,MAAM;wBACN,SAAS;wBACT,MAAM;oBACR;oBACA,YAAY;wBACV,WAAW;wBACX,SAAS;wBACT,WAAW;oBACb;oBACA,aAAa;gBACf;aACD;YAED,uCAAuC;YACvC,MAAM,SAAS,KAAK,MAAM,KAAK,MAAM,aAAa,EAAE;YAEpD,iCAAiC;YACjC,MAAM,kBAA6C;gBACjD,IAAI;gBACJ,YAAY,CAAC,SAAS,EAAE,WAAW;gBACnC,QAAQ,OAAO,MAAM,KAAK,IAAI,SAAS;gBACvC;gBACA,SAAS;oBACP,aAAa,OAAO,MAAM;oBAC1B,gBAAgB,OAAO,MAAM,CAAC,CAAC,IAAM,EAAE,QAAQ,KAAK,YAAY,MAAM;oBACtE,eAAe,OAAO,MAAM,CAAC,CAAC,IAAM,EAAE,QAAQ,KAAK,WAAW,MAAM;gBACtE;gBACA,aAAa,IAAI,OAAO,WAAW;YACrC;YAEA,OAAO;gBACL,SAAS;gBACT,MAAM;YACR;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,4BAA4B;YAC1C,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,MAAM;YACR;QACF;IACF;IAEA;;GAEC,GACD,MAAM,mBAAmB,SAAiB,EAA+C;QACvF,IAAI;YACF,IAAI,CAAC,WAAW;gBACd,OAAO;oBACL,SAAS;oBACT,OAAO;oBACP,MAAM;gBACR;YACF;YAEA,MAAM,IAAI,CAAC,aAAa,CAAC;YAEzB,MAAM,gBAAuC;gBAC3C,IAAI;gBACJ,UAAU;gBACV,UAAU;gBACV,UAAU;gBACV,QAAQ;gBACR,UAAU;gBACV,WAAW,IAAI,KAAK,KAAK,GAAG,KAAK,OAAO,WAAW;gBACnD,aAAa,IAAI,OAAO,WAAW;YACrC;YAEA,OAAO;gBACL,SAAS;gBACT,MAAM;YACR;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wBAAwB;YACtC,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,MAAM;YACR;QACF;IACF;IAEA;;GAEC,GACD,MAAM,qBAAqB,SAAiB,EAAiD;QAC3F,IAAI;YACF,IAAI,CAAC,WAAW;gBACd,OAAO;oBACL,SAAS;oBACT,OAAO;oBACP,MAAM;gBACR;YACF;YAEA,MAAM,IAAI,CAAC,aAAa,CAAC;YAEzB,MAAM,kBAA2C;gBAC/C,IAAI;gBACJ,YAAY,CAAC,SAAS,EAAE,WAAW;gBACnC,QAAQ;gBACR,UAAU;gBACV,WAAW,IAAI,KAAK,KAAK,GAAG,KAAK,OAAO,WAAW;gBACnD,aAAa,IAAI,OAAO,WAAW;gBACnC,aAAa;YACf;YAEA,OAAO;gBACL,SAAS;gBACT,MAAM;YACR;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,0BAA0B;YACxC,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,MAAM;YACR;QACF;IACF;IAEA;;GAEC,GACD,MAAM,oBAEJ;QACA,MAAM,IAAI,CAAC,aAAa,CAAC;QAEzB,OAAO;YACL,SAAS;YACT,MAAM;gBACJ,QAAQ;gBACR,SAAS;gBACT,WAAW,IAAI,OAAO,WAAW;YACnC;QACF;IACF;IAEA;;GAEC,GACD,MAAM,mBAAmB,OAAe,EAAyC;QAC/E,IAAI;YACF,IAAI,CAAC,SAAS;gBACZ,OAAO;oBACL,SAAS;oBACT,OAAO;oBACP,MAAM;gBACR;YACF;YAEA,MAAM,IAAI,CAAC,aAAa,CAAC;YAEzB,MAAM,QAAyB;gBAC7B,IAAI;gBACJ,UAAU;gBACV,OAAO;gBACP,aACE;gBACF,UAAU;oBACR,MAAM;oBACN,SAAS;oBACT,MAAM;gBACR;gBACA,YAAY;oBACV,WAAW;oBACX,SAAS;oBACT,WAAW;gBACb;gBACA,aAAa;YACf;YAEA,OAAO;gBACL,SAAS;gBACT,MAAM;YACR;QACF,EAAE,OAAO,OAAO;YACd,QAAQ,KAAK,CAAC,wBAAwB;YACtC,OAAO;gBACL,SAAS;gBACT,OAAO;gBACP,MAAM;YACR;QACF;IACF;AACF;AAKO,MAAM,gBAAgB,IAAI"}},
    {"offset": {"line": 359, "column": 0}, "map": {"version":3,"sources":["file:///Users/afos/Downloads/CtrlCheck-af-nonopen/proposal-prepper-web/src/config/app.ts"],"sourcesContent":["// SPDX-License-Identifier: AGPL-3.0-or-later\n// SPDX-FileCopyrightText: 2025 Seventeen Sierra LLC\n\n/**\n * Application Configuration\n *\n * Configuration constants and settings for the Proposal Prepper application.\n * Centralizes all configurable values used across components, services, and utilities.\n */\n\n/**\n * File Upload Configuration\n *\n * Settings for file upload validation and processing.\n * Based on requirements 1.1 and 1.2 for PDF acceptance and validation.\n */\nexport const uploadConfig = {\n  /** Accepted file types (PDF only for MVP) */\n  acceptedTypes: ['application/pdf'] as const,\n  /** Maximum file size in bytes (100MB) */\n  maxFileSize: 100 * 1024 * 1024,\n  /** Minimum file size in bytes (1KB) */\n  minFileSize: 1024,\n  /** Upload chunk size for progress tracking */\n  chunkSize: 1024 * 1024, // 1MB chunks\n  /** Maximum concurrent uploads */\n  maxConcurrentUploads: 1,\n  /** Upload timeout in milliseconds */\n  uploadTimeout: 5 * 60 * 1000, // 5 minutes\n} as const;\n\n/**\n * Analysis Configuration\n *\n * Settings for compliance analysis processing.\n * Based on requirements 2.1-2.5 for FAR/DFARS validation.\n */\nexport const analysisConfig = {\n  /** Analysis timeout in milliseconds */\n  analysisTimeout: 10 * 60 * 1000, // 10 minutes\n  /** Progress update interval in milliseconds */\n  progressUpdateInterval: 1000, // 1 second\n  /** Maximum retry attempts for failed analysis */\n  maxRetryAttempts: 3,\n  /** Retry delay in milliseconds */\n  retryDelay: 5000, // 5 seconds\n  /** Supported compliance frameworks */\n  frameworks: ['FAR', 'DFARS'] as const,\n} as const;\n\n/**\n * UI Configuration\n *\n * Settings for user interface behavior and appearance.\n * Based on requirements 4.1-4.5 and 5.1-5.5 for interface functionality.\n */\nexport const uiConfig = {\n  /** Page load timeout target in milliseconds */\n  loadTimeTarget: 5000, // 5 seconds (requirement 5.1)\n  /** Navigation transition duration in milliseconds */\n  transitionDuration: 200,\n  /** Progress update frequency in milliseconds */\n  progressUpdateFrequency: 500,\n  /** Notification auto-dismiss timeout in milliseconds */\n  notificationTimeout: 5000,\n  /** Maximum notifications to display simultaneously */\n  maxNotifications: 5,\n  /** Breakpoints for responsive design */\n  breakpoints: {\n    mobile: 768,\n    tablet: 1024,\n    desktop: 1280,\n  },\n} as const;\n\n/**\n * API Configuration\n *\n * Settings for backend service communication.\n * Configured for the federated mesh architecture.\n */\nexport const apiConfig = {\n  /** Base URL for Strands service - Docker container or localhost */\n  strandsBaseUrl:\n    process.env.NEXT_PUBLIC_STRANDS_URL ||\n    process.env.STRANDS_SERVICE_URL ||\n    (typeof window === 'undefined' ? 'http://strands:8080' : ''),\n  /** Use mock APIs for development (when external services aren't available) */\n  useMockApis: process.env.NEXT_PUBLIC_USE_MOCK_APIS === 'true',\n  /** API request timeout in milliseconds */\n  requestTimeout: 30000, // 30 seconds\n  /** Maximum retry attempts for API requests */\n  maxRetries: 3,\n  /** Retry delay in milliseconds */\n  retryDelay: 1000,\n  /** WebSocket reconnection settings */\n  websocket: {\n    reconnectInterval: 5000,\n    maxReconnectAttempts: 10,\n  },\n} as const;\n\n/**\n * Validation Configuration\n *\n * Settings for input validation and sanitization.\n */\nexport const validationConfig = {\n  /** Maximum filename length */\n  maxFilenameLength: 255,\n  /** Allowed filename characters pattern */\n  filenamePattern: /^[a-zA-Z0-9._-]+$/,\n  /** Maximum session ID length */\n  maxSessionIdLength: 128,\n  /** Session ID pattern */\n  sessionIdPattern: /^[a-zA-Z0-9-]+$/,\n} as const;\n\n/**\n * Error Configuration\n *\n * Settings for error handling and recovery.\n */\nexport const errorConfig = {\n  /** Default error message for unknown errors */\n  defaultErrorMessage: 'An unexpected error occurred. Please try again.',\n  /** Error codes for specific error types */\n  codes: {\n    UPLOAD_FAILED: 'UPLOAD_001',\n    ANALYSIS_FAILED: 'ANALYSIS_001',\n    VALIDATION_FAILED: 'VALIDATION_001',\n    NETWORK_ERROR: 'NETWORK_001',\n    TIMEOUT_ERROR: 'TIMEOUT_001',\n    SERVICE_UNAVAILABLE: 'SERVICE_002',\n    SERVICE_ERROR: 'SERVICE_003',\n  },\n  /** Error recovery strategies */\n  recovery: {\n    autoRetry: true,\n    maxAutoRetries: 2,\n    retryDelay: 2000,\n  },\n} as const;\n\n/**\n * Feature Flags\n *\n * Configuration for enabling/disabling features during development\n * and deployment phases.\n */\nexport const featureFlags = {\n  /** Enable detailed logging for debugging */\n  enableDetailedLogging: process.env.NODE_ENV === 'development',\n  /** Enable performance monitoring */\n  enablePerformanceMonitoring: true,\n  /** Enable error reporting */\n  enableErrorReporting: process.env.NODE_ENV === 'production',\n  /** Enable advanced analysis features (future enhancement) */\n  enableAdvancedAnalysis: false,\n  /** Enable real-time progress updates */\n  enableRealTimeUpdates: true,\n} as const;\n"],"names":[],"mappings":"AAAA,6CAA6C;AAC7C,oDAAoD;AAEpD;;;;;CAKC,GAED;;;;;CAKC;;;;;;;;;;;;;;;;AACM,MAAM,eAAe;IAC1B,2CAA2C,GAC3C,eAAe;QAAC;KAAkB;IAClC,uCAAuC,GACvC,aAAa,MAAM,OAAO;IAC1B,qCAAqC,GACrC,aAAa;IACb,4CAA4C,GAC5C,WAAW,OAAO;IAClB,+BAA+B,GAC/B,sBAAsB;IACtB,mCAAmC,GACnC,eAAe,IAAI,KAAK;AAC1B;AAQO,MAAM,iBAAiB;IAC5B,qCAAqC,GACrC,iBAAiB,KAAK,KAAK;IAC3B,6CAA6C,GAC7C,wBAAwB;IACxB,+CAA+C,GAC/C,kBAAkB;IAClB,gCAAgC,GAChC,YAAY;IACZ,oCAAoC,GACpC,YAAY;QAAC;QAAO;KAAQ;AAC9B;AAQO,MAAM,WAAW;IACtB,6CAA6C,GAC7C,gBAAgB;IAChB,mDAAmD,GACnD,oBAAoB;IACpB,8CAA8C,GAC9C,yBAAyB;IACzB,sDAAsD,GACtD,qBAAqB;IACrB,oDAAoD,GACpD,kBAAkB;IAClB,sCAAsC,GACtC,aAAa;QACX,QAAQ;QACR,QAAQ;QACR,SAAS;IACX;AACF;AAQO,MAAM,YAAY;IACvB,iEAAiE,GACjE,gBACE,QAAQ,GAAG,CAAC,uBAAuB,IACnC,QAAQ,GAAG,CAAC,mBAAmB,IAC/B,CAAC,uCAAgC,wBAAwB,uBAAE;IAC7D,4EAA4E,GAC5E,aAAa,QAAQ,GAAG,CAAC,yBAAyB,KAAK;IACvD,wCAAwC,GACxC,gBAAgB;IAChB,4CAA4C,GAC5C,YAAY;IACZ,gCAAgC,GAChC,YAAY;IACZ,oCAAoC,GACpC,WAAW;QACT,mBAAmB;QACnB,sBAAsB;IACxB;AACF;AAOO,MAAM,mBAAmB;IAC9B,4BAA4B,GAC5B,mBAAmB;IACnB,wCAAwC,GACxC,iBAAiB;IACjB,8BAA8B,GAC9B,oBAAoB;IACpB,uBAAuB,GACvB,kBAAkB;AACpB;AAOO,MAAM,cAAc;IACzB,6CAA6C,GAC7C,qBAAqB;IACrB,yCAAyC,GACzC,OAAO;QACL,eAAe;QACf,iBAAiB;QACjB,mBAAmB;QACnB,eAAe;QACf,eAAe;QACf,qBAAqB;QACrB,eAAe;IACjB;IACA,8BAA8B,GAC9B,UAAU;QACR,WAAW;QACX,gBAAgB;QAChB,YAAY;IACd;AACF;AAQO,MAAM,eAAe;IAC1B,0CAA0C,GAC1C,uBAAuB,oDAAyB;IAChD,kCAAkC,GAClC,6BAA6B;IAC7B,2BAA2B,GAC3B,sBAAsB,oDAAyB;IAC/C,2DAA2D,GAC3D,wBAAwB;IACxB,sCAAsC,GACtC,uBAAuB;AACzB"}},
    {"offset": {"line": 464, "column": 0}, "map": {"version":3,"sources":["file:///Users/afos/Downloads/CtrlCheck-af-nonopen/proposal-prepper-web/src/utils/performance.ts"],"sourcesContent":["/*\n * SPDX-License-Identifier: AGPL-3.0-or-later\n * SPDX-FileCopyrightText: 2025 Seventeen Sierra LLC\n */\n\n/**\n * Performance Utilities\n *\n * Implements caching strategies and performance optimizations\n * for the Proposal Prepper application.\n *\n * Requirement 5.1: Load time performance optimization\n */\n\n/**\n * Simple in-memory cache with TTL support\n */\nclass MemoryCache<T> {\n  private cache = new Map<string, { value: T; expires: number }>();\n  private defaultTTL: number;\n\n  constructor(defaultTTL = 5 * 60 * 1000) {\n    // 5 minutes default\n    this.defaultTTL = defaultTTL;\n  }\n\n  set(key: string, value: T, ttl?: number): void {\n    const expires = Date.now() + (ttl ?? this.defaultTTL);\n    this.cache.set(key, { value, expires });\n  }\n\n  get(key: string): T | null {\n    const item = this.cache.get(key);\n    if (!item) return null;\n\n    if (Date.now() > item.expires) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    return item.value;\n  }\n\n  has(key: string): boolean {\n    return this.get(key) !== null;\n  }\n\n  delete(key: string): boolean {\n    return this.cache.delete(key);\n  }\n\n  clear(): void {\n    this.cache.clear();\n  }\n\n  size(): number {\n    // Clean expired entries first\n    const now = Date.now();\n    for (const [key, item] of this.cache.entries()) {\n      if (now > item.expires) {\n        this.cache.delete(key);\n      }\n    }\n    return this.cache.size;\n  }\n}\n\n/**\n * Browser storage cache with fallback to memory\n */\nclass BrowserCache<T> {\n  private memoryCache: MemoryCache<T>;\n  private storageKey: string;\n\n  constructor(storageKey: string, defaultTTL = 30 * 60 * 1000) {\n    // 30 minutes default\n    this.storageKey = storageKey;\n    this.memoryCache = new MemoryCache<T>(defaultTTL);\n  }\n\n  private isStorageAvailable(): boolean {\n    try {\n      return typeof window !== 'undefined' && window.localStorage !== undefined;\n    } catch {\n      return false;\n    }\n  }\n\n  private getStorageKey(key: string): string {\n    return `${this.storageKey}:${key}`;\n  }\n\n  set(key: string, value: T, ttl?: number): void {\n    // Always set in memory cache\n    this.memoryCache.set(key, value, ttl);\n\n    // Try to set in localStorage if available\n    if (this.isStorageAvailable()) {\n      try {\n        const expires = Date.now() + (ttl ?? 30 * 60 * 1000);\n        const item = { value, expires };\n        localStorage.setItem(this.getStorageKey(key), JSON.stringify(item));\n      } catch (error) {\n        console.warn('Failed to save to localStorage:', error);\n      }\n    }\n  }\n\n  get(key: string): T | null {\n    // Try memory cache first (fastest)\n    const memoryValue = this.memoryCache.get(key);\n    if (memoryValue !== null) {\n      return memoryValue;\n    }\n\n    // Try localStorage if available\n    if (this.isStorageAvailable()) {\n      try {\n        const stored = localStorage.getItem(this.getStorageKey(key));\n        if (stored) {\n          const item = JSON.parse(stored);\n          if (Date.now() <= item.expires) {\n            // Restore to memory cache for faster access\n            this.memoryCache.set(key, item.value);\n            return item.value;\n          } else {\n            // Clean up expired item\n            localStorage.removeItem(this.getStorageKey(key));\n          }\n        }\n      } catch (error) {\n        console.warn('Failed to read from localStorage:', error);\n      }\n    }\n\n    return null;\n  }\n\n  has(key: string): boolean {\n    return this.get(key) !== null;\n  }\n\n  delete(key: string): void {\n    this.memoryCache.delete(key);\n    if (this.isStorageAvailable()) {\n      try {\n        localStorage.removeItem(this.getStorageKey(key));\n      } catch (error) {\n        console.warn('Failed to delete from localStorage:', error);\n      }\n    }\n  }\n\n  clear(): void {\n    this.memoryCache.clear();\n    if (this.isStorageAvailable()) {\n      try {\n        const keys = Object.keys(localStorage);\n        for (const key of keys) {\n          if (key.startsWith(`${this.storageKey}:`)) {\n            localStorage.removeItem(key);\n          }\n        }\n      } catch (error) {\n        console.warn('Failed to clear localStorage:', error);\n      }\n    }\n  }\n}\n\n/**\n * Debounce function for performance optimization\n */\nexport function debounce<T extends (...args: unknown[]) => unknown>(\n  func: T,\n  wait: number\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout | null = null;\n\n  return (...args: Parameters<T>) => {\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => func(...args), wait);\n  };\n}\n\n/**\n * Throttle function for performance optimization\n */\nexport function throttle<T extends (...args: unknown[]) => unknown>(\n  func: T,\n  limit: number\n): (...args: Parameters<T>) => void {\n  let inThrottle = false;\n\n  return (...args: Parameters<T>) => {\n    if (!inThrottle) {\n      func(...args);\n      inThrottle = true;\n      setTimeout(() => {\n        inThrottle = false;\n      }, limit);\n    }\n  };\n}\n\n/**\n * Memoization with cache for expensive computations\n */\nexport function memoize<T extends (...args: unknown[]) => unknown>(\n  func: T,\n  keyGenerator?: (...args: Parameters<T>) => string\n): T {\n  const cache = new Map<string, ReturnType<T>>();\n\n  return ((...args: Parameters<T>): ReturnType<T> => {\n    const key = keyGenerator ? keyGenerator(...args) : JSON.stringify(args);\n\n    if (cache.has(key)) {\n      return cache.get(key)!;\n    }\n\n    const result = func(...args) as ReturnType<T>;\n    cache.set(key, result);\n    return result;\n  }) as T;\n}\n\n/**\n * Preload resources for better performance\n */\nexport function preloadResource(href: string, as: string): void {\n  if (typeof window === 'undefined') return;\n\n  const link = document.createElement('link');\n  link.rel = 'preload';\n  link.href = href;\n  link.as = as;\n  document.head.appendChild(link);\n}\n\n/**\n * Lazy load images with intersection observer\n */\nexport function lazyLoadImage(img: HTMLImageElement, src: string): void {\n  if (typeof window === 'undefined' || !('IntersectionObserver' in window)) {\n    img.src = src;\n    return;\n  }\n\n  const observer = new IntersectionObserver(\n    (entries) => {\n      entries.forEach((entry) => {\n        if (entry.isIntersecting) {\n          img.src = src;\n          observer.unobserve(img);\n        }\n      });\n    },\n    { threshold: 0.1 }\n  );\n\n  observer.observe(img);\n}\n\n/**\n * Performance monitoring utilities\n */\nexport namespace PerformanceMonitor {\n  const marks = new Map<string, number>();\n\n  export function mark(name: string): void {\n    if (typeof window !== 'undefined' && window.performance) {\n      window.performance.mark(name);\n      marks.set(name, Date.now());\n    }\n  }\n\n  export function measure(name: string, startMark: string, endMark?: string): number | null {\n    if (typeof window === 'undefined' || !window.performance) {\n      // Fallback measurement\n      const startTime = marks.get(startMark);\n      const endTime = endMark ? marks.get(endMark) : Date.now();\n      return startTime && endTime ? endTime - startTime : null;\n    }\n\n    try {\n      if (endMark) {\n        window.performance.measure(name, startMark, endMark);\n      } else {\n        window.performance.measure(name, startMark);\n      }\n\n      const entries = window.performance.getEntriesByName(name, 'measure');\n      return entries.length > 0 ? entries[entries.length - 1].duration : null;\n    } catch (error) {\n      console.warn('Performance measurement failed:', error);\n      return null;\n    }\n  }\n\n  export function getNavigationTiming(): Record<string, number> | null {\n    if (typeof window === 'undefined' || !window.performance?.timing) {\n      return null;\n    }\n\n    const timing = window.performance.timing;\n    return {\n      domContentLoaded: timing.domContentLoadedEventEnd - timing.navigationStart,\n      loadComplete: timing.loadEventEnd - timing.navigationStart,\n      domInteractive: timing.domInteractive - timing.navigationStart,\n      firstPaint: timing.responseEnd - timing.navigationStart,\n    };\n  }\n}\n\n// Export cache instances for common use cases\nexport const apiCache = new BrowserCache<unknown>('proposal-prepper-api', 10 * 60 * 1000); // 10 minutes\nexport const uiStateCache = new MemoryCache<unknown>(60 * 1000); // 1 minute\nexport const resultsCache = new BrowserCache<unknown>('proposal-prepper-results', 60 * 60 * 1000); // 1 hour\n\n// Export cache classes for custom instances\nexport { MemoryCache, BrowserCache };\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 721, "column": 0}, "map": {"version":3,"sources":["file:///Users/afos/Downloads/CtrlCheck-af-nonopen/proposal-prepper-web/src/config/api-config.ts"],"sourcesContent":["/*\n * SPDX-License-Identifier: AGPL-3.0-or-later\n * SPDX-FileCopyrightText: 2025 Seventeen Sierra LLC\n */\n\n/**\n * Framework-Independent API Configuration\n *\n * Provides flexible configuration for different deployment scenarios\n * and framework integrations. Supports environment-based configuration\n * and runtime switching between real and mock APIs.\n */\n\nexport interface ApiEndpoints {\n  upload: string;\n  uploadStatus: (sessionId: string) => string;\n  analysisStart: string;\n  analysisStatus: (sessionId: string) => string;\n  analysisResults: (sessionId: string) => string;\n  issueDetails: (issueId: string) => string;\n  health: string;\n}\n\nexport interface ApiConfiguration {\n  baseUrl: string;\n  endpoints: ApiEndpoints;\n  useMock: boolean;\n  timeout: number;\n  retries: number;\n  retryDelay: number;\n}\n\n/**\n * Default API endpoints structure\n */\nconst DEFAULT_ENDPOINTS: ApiEndpoints = {\n  upload: '/api/documents/upload',\n  uploadStatus: (sessionId: string) => `/api/documents/upload/${sessionId}`,\n  analysisStart: '/api/analysis/start',\n  analysisStatus: (sessionId: string) => `/api/analysis/${sessionId}`,\n  analysisResults: (sessionId: string) => `/api/analysis/${sessionId}/results`,\n  issueDetails: (issueId: string) => `/api/results/issues/${issueId}`,\n  health: '/api/health',\n};\n\n/**\n * Environment variable names for configuration\n */\nconst ENV_VARS = {\n  STRANDS_API_URL: 'STRANDS_API_URL',\n  MOCK_API_URL: 'MOCK_API_URL',\n  USE_MOCK_API: 'USE_MOCK_API',\n  API_TIMEOUT: 'API_TIMEOUT',\n  API_RETRIES: 'API_RETRIES',\n  API_RETRY_DELAY: 'API_RETRY_DELAY',\n} as const;\n\n/**\n * Get environment variable with fallback\n */\nfunction getEnvVar(name: string, fallback: string = ''): string {\n  if (typeof process !== 'undefined' && process.env) {\n    return process.env[name] || fallback;\n  }\n  return fallback;\n}\n\n/**\n * Get boolean environment variable\n */\nfunction getBooleanEnvVar(name: string, fallback: boolean = false): boolean {\n  const value = getEnvVar(name);\n  if (!value) return fallback;\n  return value.toLowerCase() === 'true' || value === '1';\n}\n\n/**\n * Get number environment variable\n */\nfunction getNumberEnvVar(name: string, fallback: number): number {\n  const value = getEnvVar(name);\n  if (!value) return fallback;\n  const parsed = parseInt(value, 10);\n  return Number.isNaN(parsed) ? fallback : parsed;\n}\n\n/**\n * Determine if we should use mock APIs\n */\nfunction shouldUseMockApi(): boolean {\n  // Explicit environment variable override\n  if (getEnvVar(ENV_VARS.USE_MOCK_API)) {\n    return getBooleanEnvVar(ENV_VARS.USE_MOCK_API);\n  }\n\n  // Development mode defaults to mock\n  if (getEnvVar('NODE_ENV') === 'development') {\n    return true;\n  }\n\n  // Browser-based detection for client-side\n  if (typeof window !== 'undefined') {\n    // Check URL path for mock indicator\n    if (window.location.pathname.includes('/mock')) {\n      return true;\n    }\n\n    // Check localStorage override\n    const mockOverride = localStorage.getItem('use-mock-api');\n    if (mockOverride !== null) {\n      return mockOverride === 'true';\n    }\n  }\n\n  return false;\n}\n\n/**\n * Get the appropriate API base URL\n */\nfunction getApiBaseUrl(): string {\n  const useMock = shouldUseMockApi();\n\n  if (useMock) {\n    // Mock API URL (could be Next.js routes, Express server, etc.)\n    const mockUrl = getEnvVar(ENV_VARS.MOCK_API_URL);\n    if (mockUrl) return mockUrl;\n\n    // Default mock URLs for different environments\n    if (typeof window !== 'undefined') {\n      // Browser environment - use current origin for Next.js routes\n      return window.location.origin;\n    } else {\n      // Server environment - default to localhost\n      return 'http://localhost:3000';\n    }\n  }\n\n  // Real Strands API URL - prioritize Docker container networking\n  const realUrl = getEnvVar(ENV_VARS.STRANDS_API_URL) || getEnvVar('STRANDS_SERVICE_URL');\n  if (realUrl) return realUrl;\n\n  // Default real API URL - use Docker service name for server-side, localhost for client-side\n  if (typeof window !== 'undefined') {\n    // Browser environment - use localhost\n    return 'http://localhost:8080';\n  } else {\n    // Server environment - use Docker service name\n    return 'http://strands:8080';\n  }\n}\n\n/**\n * Create API configuration based on environment\n */\nexport function createApiConfiguration(overrides?: Partial<ApiConfiguration>): ApiConfiguration {\n  const baseConfig: ApiConfiguration = {\n    baseUrl: getApiBaseUrl(),\n    endpoints: DEFAULT_ENDPOINTS,\n    useMock: shouldUseMockApi(),\n    timeout: getNumberEnvVar(ENV_VARS.API_TIMEOUT, 30000), // 30 seconds\n    retries: getNumberEnvVar(ENV_VARS.API_RETRIES, 3),\n    retryDelay: getNumberEnvVar(ENV_VARS.API_RETRY_DELAY, 1000), // 1 second\n  };\n\n  return { ...baseConfig, ...overrides };\n}\n\n/**\n * Default API configuration instance\n */\nexport const apiConfiguration = createApiConfiguration();\n\n/**\n * Runtime API configuration switching\n */\nexport class ApiConfigurationManager {\n  private static instance: ApiConfigurationManager;\n  private config: ApiConfiguration;\n  private listeners: Set<(config: ApiConfiguration) => void> = new Set();\n\n  private constructor() {\n    this.config = createApiConfiguration();\n  }\n\n  static getInstance(): ApiConfigurationManager {\n    if (!ApiConfigurationManager.instance) {\n      ApiConfigurationManager.instance = new ApiConfigurationManager();\n    }\n    return ApiConfigurationManager.instance;\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfiguration(): ApiConfiguration {\n    return { ...this.config };\n  }\n\n  /**\n   * Update configuration\n   */\n  updateConfiguration(updates: Partial<ApiConfiguration>): void {\n    this.config = { ...this.config, ...updates };\n    this.notifyListeners();\n  }\n\n  /**\n   * Switch to mock API\n   */\n  useMockApi(mockBaseUrl?: string): void {\n    this.updateConfiguration({\n      useMock: true,\n      baseUrl: mockBaseUrl || this.config.baseUrl,\n    });\n  }\n\n  /**\n   * Switch to real API\n   */\n  useRealApi(realBaseUrl?: string): void {\n    this.updateConfiguration({\n      useMock: false,\n      baseUrl: realBaseUrl || getEnvVar(ENV_VARS.STRANDS_API_URL, 'http://localhost:8080'),\n    });\n  }\n\n  /**\n   * Subscribe to configuration changes\n   */\n  subscribe(listener: (config: ApiConfiguration) => void): () => void {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n\n  /**\n   * Notify all listeners of configuration changes\n   */\n  private notifyListeners(): void {\n    this.listeners.forEach((listener) => {\n      listener(this.config);\n    });\n  }\n\n  /**\n   * Reset to default configuration\n   */\n  reset(): void {\n    this.config = createApiConfiguration();\n    this.notifyListeners();\n  }\n}\n\n/**\n * Global configuration manager instance\n */\nexport const apiConfigManager = ApiConfigurationManager.getInstance();\n\n/**\n * Utility functions for common configuration scenarios\n */\nexport const ApiConfigUtils = {\n  /**\n   * Configure for Next.js development\n   */\n  configureForNextJs(port = 3000): void {\n    apiConfigManager.updateConfiguration({\n      baseUrl: `http://localhost:${port}`,\n      useMock: true,\n    });\n  },\n\n  /**\n   * Configure for Express server\n   */\n  configureForExpress(port = 8080): void {\n    apiConfigManager.updateConfiguration({\n      baseUrl: `http://localhost:${port}`,\n      useMock: false,\n    });\n  },\n\n  /**\n   * Configure for standalone mock server\n   */\n  configureForStandaloneMock(port = 8081): void {\n    apiConfigManager.updateConfiguration({\n      baseUrl: `http://localhost:${port}`,\n      useMock: true,\n    });\n  },\n\n  /**\n   * Configure for production\n   */\n  configureForProduction(apiUrl: string): void {\n    apiConfigManager.updateConfiguration({\n      baseUrl: apiUrl,\n      useMock: false,\n      timeout: 60000, // Longer timeout for production\n      retries: 5, // More retries for production\n    });\n  },\n\n  /**\n   * Get configuration for current environment\n   */\n  getEnvironmentConfig(): ApiConfiguration {\n    return apiConfigManager.getConfiguration();\n  },\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 955, "column": 0}, "map": {"version":3,"sources":["file:///Users/afos/Downloads/CtrlCheck-af-nonopen/proposal-prepper-services/src/ai-router-client.ts"],"sourcesContent":["// SPDX-License-Identifier: AGPL-3.0-or-later\n// SPDX-FileCopyrightText: 2025 Seventeen Sierra LLC\n\n/**\n * Strands API Client\n *\n * HTTP/REST and WebSocket client for communicating with the Strands service.\n * Provides document upload, analysis orchestration, and results retrieval.\n * Implements requirements 1.1, 2.1, and 3.1 for API integration.\n *\n * Performance optimizations for Requirement 5.1: Load time performance\n */\n\nimport { apiConfig, errorConfig } from '@/config/app';\nimport { apiCache, PerformanceMonitor } from '@/utils/performance';\n\n/**\n * API Response wrapper for consistent error handling\n */\nexport interface ApiResponse<T> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  code?: string;\n}\n\n/**\n * Upload session data from Strands API\n */\nexport interface UploadSessionResponse {\n  id: string;\n  filename: string;\n  fileSize: number;\n  mimeType: string;\n  status: 'pending' | 'uploading' | 'processing' | 'completed' | 'failed';\n  progress: number;\n  startedAt: string;\n  completedAt?: string;\n  errorMessage?: string;\n  s3Key?: string;\n}\n\n/**\n * Analysis session data from Strands API\n */\nexport interface AnalysisSessionResponse {\n  id: string;\n  proposalId: string;\n  status: 'queued' | 'extracting' | 'analyzing' | 'validating' | 'completed' | 'failed';\n  progress: number;\n  startedAt: string;\n  completedAt?: string;\n  estimatedCompletion?: string;\n  currentStep: string;\n}\n\n/**\n * Compliance results from Strands API\n */\nexport interface ComplianceResultsResponse {\n  id: string;\n  proposalId: string;\n  status: 'pass' | 'fail' | 'warning';\n  issues: ComplianceIssue[];\n  summary: {\n    totalIssues: number;\n    criticalIssues: number;\n    warningIssues: number;\n  };\n  generatedAt: string;\n}\n\n/**\n * Individual compliance issue\n */\nexport interface ComplianceIssue {\n  id: string;\n  severity: 'critical' | 'warning' | 'info';\n  title: string;\n  description: string;\n  regulation: {\n    framework: 'FAR' | 'DFARS';\n    section: string;\n    reference: string;\n  };\n  location?: {\n    page: number;\n    section: string;\n    text: string;\n  };\n  remediation?: string;\n}\n\n/**\n * WebSocket message types for real-time updates\n */\nexport interface WebSocketMessage {\n  type: 'upload_progress' | 'analysis_progress' | 'analysis_complete' | 'error';\n  sessionId: string;\n  data: unknown;\n}\n\n/**\n * HTTP client with retry logic and error handling\n */\nclass HttpClient {\n  private baseUrl: string;\n  private timeout: number;\n  private maxRetries: number;\n  private retryDelay: number;\n\n  constructor(baseUrl: string) {\n    this.baseUrl = baseUrl;\n    this.timeout = apiConfig.requestTimeout;\n    this.maxRetries = apiConfig.maxRetries;\n    this.retryDelay = apiConfig.retryDelay;\n  }\n\n  /**\n   * Make HTTP request with retry logic and caching\n   * Performance optimization for Requirement 5.1\n   */\n  private async makeRequest<T>(\n    endpoint: string,\n    options: RequestInit = {},\n    cacheKey?: string,\n    cacheTTL?: number\n  ): Promise<ApiResponse<T>> {\n    // Check cache for GET requests\n    if (options.method === 'GET' && cacheKey) {\n      const cached = apiCache.get(cacheKey);\n      if (cached) {\n        return { success: true, data: cached as T };\n      }\n    }\n\n    const url = `${this.baseUrl}${endpoint}`;\n    let lastError: Error | null = null;\n\n    // Performance monitoring\n    const requestId = `api-request-${Date.now()}`;\n    PerformanceMonitor.mark(`${requestId}-start`);\n\n    for (let attempt = 0; attempt <= this.maxRetries; attempt++) {\n      try {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n\n        const response = await fetch(url, {\n          ...options,\n          signal: controller.signal,\n          headers: {\n            'Content-Type': 'application/json',\n            ...options.headers,\n          },\n        });\n\n        clearTimeout(timeoutId);\n\n        if (!response.ok) {\n          throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n        }\n\n        const data = await response.json();\n\n        // Cache successful GET responses\n        if (options.method === 'GET' && cacheKey && data) {\n          apiCache.set(cacheKey, data, cacheTTL);\n        }\n\n        // Performance monitoring\n        PerformanceMonitor.mark(`${requestId}-end`);\n        const duration = PerformanceMonitor.measure(\n          requestId,\n          `${requestId}-start`,\n          `${requestId}-end`\n        );\n        if (duration && duration > 1000) {\n          console.warn(`Slow API request: ${endpoint} took ${duration}ms`);\n        }\n\n        // Check if response is envelope-wrapped (success/data pattern) which our API uses\n        // This prevents double-wrapping where response.data becomes { success: true, data: ... }\n        if (data && typeof data === 'object' && 'success' in data && 'data' in data) {\n          return data as ApiResponse<T>;\n        }\n\n        return { success: true, data };\n      } catch (error) {\n        lastError = error as Error;\n\n        // Don't retry on client errors (4xx)\n        if (error instanceof Error && error.message.includes('HTTP 4')) {\n          break;\n        }\n\n        // Wait before retry (except on last attempt)\n        if (attempt < this.maxRetries) {\n          await new Promise((resolve) => setTimeout(resolve, this.retryDelay * (attempt + 1)));\n        }\n      }\n    }\n\n    return {\n      success: false,\n      error: lastError?.message || errorConfig.defaultErrorMessage,\n      code: this.getErrorCode(lastError),\n    };\n  }\n\n  /**\n   * Get appropriate error code based on error type\n   */\n  private getErrorCode(error: Error | null): string {\n    if (!error) return errorConfig.codes.NETWORK_ERROR;\n\n    if (error.name === 'AbortError') {\n      return errorConfig.codes.TIMEOUT_ERROR;\n    }\n\n    if (error.message.includes('HTTP 4')) {\n      return errorConfig.codes.VALIDATION_FAILED;\n    }\n\n    // Check for specific connection errors\n    if (\n      error.message.includes('ECONNREFUSED') ||\n      error.message.includes('ENOTFOUND') ||\n      error.message.includes('ECONNRESET')\n    ) {\n      return 'SERVICE_UNAVAILABLE';\n    }\n\n    if (error.message.includes('HTTP 5')) {\n      return 'SERVICE_ERROR';\n    }\n\n    return errorConfig.codes.NETWORK_ERROR;\n  }\n\n  /**\n   * GET request with caching\n   */\n  async get<T>(endpoint: string, cacheTTL?: number): Promise<ApiResponse<T>> {\n    const cacheKey = `GET:${endpoint}`;\n    return this.makeRequest<T>(endpoint, { method: 'GET' }, cacheKey, cacheTTL);\n  }\n\n  /**\n   * POST request\n   */\n  async post<T>(endpoint: string, data?: unknown): Promise<ApiResponse<T>> {\n    return this.makeRequest<T>(endpoint, {\n      method: 'POST',\n      body: data ? JSON.stringify(data) : undefined,\n    });\n  }\n\n  /**\n   * PUT request\n   */\n  async put<T>(endpoint: string, data?: unknown): Promise<ApiResponse<T>> {\n    return this.makeRequest<T>(endpoint, {\n      method: 'PUT',\n      body: data ? JSON.stringify(data) : undefined,\n    });\n  }\n\n  /**\n   * DELETE request\n   */\n  async delete<T>(endpoint: string): Promise<ApiResponse<T>> {\n    return this.makeRequest<T>(endpoint, { method: 'DELETE' });\n  }\n\n  /**\n   * Upload file with progress tracking\n   */\n  async uploadFile(\n    endpoint: string,\n    file: File,\n    onProgress?: (progress: number) => void\n  ): Promise<ApiResponse<UploadSessionResponse>> {\n    return new Promise((resolve) => {\n      const xhr = new XMLHttpRequest();\n      const formData = new FormData();\n      formData.append('file', file);\n\n      xhr.upload.addEventListener('progress', (event) => {\n        if (event.lengthComputable && onProgress) {\n          const progress = (event.loaded / event.total) * 100;\n          onProgress(progress);\n        }\n      });\n\n      xhr.addEventListener('load', () => {\n        try {\n          if (xhr.status >= 200 && xhr.status < 300) {\n            const data = JSON.parse(xhr.responseText);\n            // Check for envelope wrapping here too\n            if (data && typeof data === 'object' && 'success' in data && 'data' in data) {\n              resolve(data);\n            } else {\n              resolve({ success: true, data });\n            }\n          } else {\n            resolve({\n              success: false,\n              error: `Upload failed: ${xhr.statusText}`,\n              code: errorConfig.codes.UPLOAD_FAILED,\n            });\n          }\n        } catch (_error) {\n          resolve({\n            success: false,\n            error: 'Failed to parse upload response',\n            code: errorConfig.codes.UPLOAD_FAILED,\n          });\n        }\n      });\n\n      xhr.addEventListener('error', () => {\n        resolve({\n          success: false,\n          error: 'Upload network error',\n          code: errorConfig.codes.NETWORK_ERROR,\n        });\n      });\n\n      xhr.addEventListener('timeout', () => {\n        resolve({\n          success: false,\n          error: 'Upload timeout',\n          code: errorConfig.codes.TIMEOUT_ERROR,\n        });\n      });\n\n      xhr.timeout = this.timeout;\n      xhr.open('POST', `${this.baseUrl}${endpoint}`);\n      xhr.send(formData);\n    });\n  }\n}\n\n/**\n * WebSocket client for real-time updates\n */\nclass WebSocketClient {\n  private ws: WebSocket | null = null;\n  private url: string;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts: number;\n  private reconnectInterval: number;\n  private listeners: Map<string, Set<(message: WebSocketMessage) => void>> = new Map();\n\n  constructor(baseUrl: string) {\n    this.url = `${baseUrl.replace('http', 'ws')}/ws`;\n    this.maxReconnectAttempts = apiConfig.websocket.maxReconnectAttempts;\n    this.reconnectInterval = apiConfig.websocket.reconnectInterval;\n  }\n\n  /**\n   * Connect to WebSocket\n   */\n  connect(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        this.ws = new WebSocket(this.url);\n\n        this.ws.onopen = () => {\n          this.reconnectAttempts = 0;\n          resolve();\n        };\n\n        this.ws.onmessage = (event) => {\n          try {\n            const message: WebSocketMessage = JSON.parse(event.data);\n            this.notifyListeners(message.type, message);\n          } catch (error) {\n            console.error('Failed to parse WebSocket message:', error);\n          }\n        };\n\n        this.ws.onclose = () => {\n          this.handleDisconnection();\n        };\n\n        this.ws.onerror = (error) => {\n          console.error('WebSocket error:', error);\n          reject(error);\n        };\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Handle WebSocket disconnection with reconnection logic\n   */\n  private handleDisconnection() {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      setTimeout(() => {\n        this.connect().catch(console.error);\n      }, this.reconnectInterval * this.reconnectAttempts);\n    }\n  }\n\n  /**\n   * Subscribe to WebSocket messages of a specific type\n   */\n  subscribe(type: string, callback: (message: WebSocketMessage) => void) {\n    if (!this.listeners.has(type)) {\n      this.listeners.set(type, new Set());\n    }\n    this.listeners.get(type)!.add(callback);\n  }\n\n  /**\n   * Unsubscribe from WebSocket messages\n   */\n  unsubscribe(type: string, callback: (message: WebSocketMessage) => void) {\n    const typeListeners = this.listeners.get(type);\n    if (typeListeners) {\n      typeListeners.delete(callback);\n    }\n  }\n\n  /**\n   * Notify all listeners of a message type\n   */\n  private notifyListeners(type: string, message: WebSocketMessage) {\n    const typeListeners = this.listeners.get(type);\n    if (typeListeners) {\n      typeListeners.forEach((callback) => {\n        callback(message);\n      });\n    }\n  }\n\n  /**\n   * Send message through WebSocket\n   */\n  send(message: unknown) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(message));\n    }\n  }\n\n  /**\n   * Close WebSocket connection\n   */\n  disconnect() {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n  }\n\n  /**\n   * Check if WebSocket is connected\n   */\n  isConnected(): boolean {\n    return this.ws?.readyState === WebSocket.OPEN;\n  }\n}\n\n/**\n * Main Strands API Client\n *\n * Provides HTTP/REST * AI Router Client\n * \n * Handles communication with the external AI service (formerly Strands).\n * Renamed from StrandsApiClient to AIRouterClient to be more generic.lements error handling, retry logic, and real-time updates.\n */\nexport class AIRouterClient {\n  private httpClient: HttpClient;\n  private wsClient: WebSocketClient;\n  private baseUrl: string;\n  private lastHealthCheck: { timestamp: number; healthy: boolean } | null = null;\n  private healthCheckCacheMs = 30000; // Cache health check for 30 seconds\n\n  constructor(baseUrl: string = apiConfig.strandsBaseUrl) {\n    this.baseUrl = baseUrl;\n    this.httpClient = new HttpClient(baseUrl);\n    this.wsClient = new WebSocketClient(baseUrl);\n  }\n\n  /**\n   * Get the base URL being used by this client\n   */\n  getBaseUrl(): string {\n    return this.baseUrl;\n  }\n\n  // Document Upload Methods\n\n  /**\n   * Upload a document file\n   * Requirement 1.1: Accept PDF format files\n   */\n  async uploadDocument(\n    file: File,\n    onProgress?: (progress: number) => void\n  ): Promise<ApiResponse<UploadSessionResponse>> {\n    return this.httpClient.uploadFile('/api/documents/upload', file, onProgress);\n  }\n\n  /**\n   * Get upload session status with short-term caching\n   */\n  async getUploadStatus(sessionId: string): Promise<ApiResponse<UploadSessionResponse>> {\n    return this.httpClient.get<UploadSessionResponse>(`/api/documents/upload/${sessionId}`, 30000); // 30 seconds cache\n  }\n\n  // Analysis Methods\n\n  /**\n   * Start compliance analysis\n   * Requirement 2.1: Validate against core FAR/DFARS requirements\n   */\n  async startAnalysis(\n    proposalId: string,\n    documentId?: string,\n    filename?: string,\n    s3Key?: string\n  ): Promise<ApiResponse<AnalysisSessionResponse>> {\n    // Check service health before attempting analysis\n    if (!(await this.isServiceHealthy())) {\n      return {\n        success: false,\n        error: 'Strands service is not available. Please try again later.',\n        code: 'SERVICE_UNAVAILABLE',\n      };\n    }\n\n    return this.httpClient.post<AnalysisSessionResponse>('/api/analysis/start', {\n      proposal_id: proposalId,\n      document_id: documentId || proposalId,\n      filename: filename || 'document.pdf',\n      s3_key: s3Key || `uploads/${proposalId}/${filename || 'document.pdf'}`,\n      frameworks: ['FAR', 'DFARS'],\n    });\n  }\n\n  /**\n   * Get analysis session status with short-term caching\n   */\n  async getAnalysisStatus(sessionId: string): Promise<ApiResponse<AnalysisSessionResponse>> {\n    return this.httpClient.get<AnalysisSessionResponse>(`/api/analysis/${sessionId}`, 15000); // 15 seconds cache\n  }\n\n  /**\n   * Cancel analysis session\n   */\n  async cancelAnalysis(sessionId: string): Promise<ApiResponse<void>> {\n    return this.httpClient.delete<void>(`/api/analysis/${sessionId}`);\n  }\n\n  // Results Methods\n\n  /**\n   * Get compliance analysis results with longer caching\n   * Requirement 3.1: Show compliance status and findings\n   */\n  async getResults(sessionId: string): Promise<ApiResponse<ComplianceResultsResponse>> {\n    return this.httpClient.get<ComplianceResultsResponse>(\n      `/api/analysis/${sessionId}/results`,\n      300000\n    ); // 5 minutes cache\n  }\n\n  /**\n   * Get specific compliance issue details with caching\n   */\n  async getIssueDetails(issueId: string): Promise<ApiResponse<ComplianceIssue>> {\n    return this.httpClient.get<ComplianceIssue>(`/api/results/issues/${issueId}`, 600000); // 10 minutes cache\n  }\n\n  // WebSocket Methods\n\n  /**\n   * Connect to real-time updates\n   */\n  async connectWebSocket(): Promise<void> {\n    return this.wsClient.connect();\n  }\n\n  /**\n   * Subscribe to upload progress updates\n   */\n  subscribeToUploadProgress(callback: (progress: WebSocketMessage) => void) {\n    this.wsClient.subscribe('upload_progress', callback);\n  }\n\n  /**\n   * Subscribe to analysis progress updates\n   */\n  subscribeToAnalysisProgress(callback: (progress: WebSocketMessage) => void) {\n    this.wsClient.subscribe('analysis_progress', callback);\n  }\n\n  /**\n   * Subscribe to analysis completion\n   */\n  subscribeToAnalysisComplete(callback: (result: WebSocketMessage) => void) {\n    this.wsClient.subscribe('analysis_complete', callback);\n  }\n\n  /**\n   * Subscribe to error notifications\n   */\n  subscribeToErrors(callback: (error: WebSocketMessage) => void) {\n    this.wsClient.subscribe('error', callback);\n  }\n\n  /**\n   * Unsubscribe from WebSocket updates\n   */\n  unsubscribe(type: string, callback: (message: WebSocketMessage) => void) {\n    this.wsClient.unsubscribe(type, callback);\n  }\n\n  /**\n   * Disconnect from WebSocket\n   */\n  disconnectWebSocket() {\n    this.wsClient.disconnect();\n  }\n\n  /**\n   * Simulate document upload using seeded data\n   */\n  async simulateUpload(filename: string): Promise<ApiResponse<UploadSessionResponse>> {\n    // Check service health\n    if (!(await this.isServiceHealthy())) {\n      return {\n        success: false,\n        error: 'Strands service is not available',\n        code: 'SERVICE_UNAVAILABLE',\n      };\n    }\n\n    return this.httpClient.post<UploadSessionResponse>('/api/documents/simulate-upload', {\n      filename,\n    });\n  }\n\n  /**\n   * Check WebSocket connection status\n   */\n  isWebSocketConnected(): boolean {\n    return this.wsClient.isConnected();\n  }\n\n  // Health Check\n\n  /**\n   * Check if Strands service is available\n   */\n  async healthCheck(): Promise<\n    ApiResponse<{ status: string; version: string; checks?: Record<string, string> }>\n  > {\n    const result = await this.httpClient.get<{\n      status: string;\n      version: string;\n      checks?: Record<string, string>;\n    }>('/api/health');\n\n    // Update health check cache\n    this.lastHealthCheck = {\n      timestamp: Date.now(),\n      healthy:\n        result.success && (result.data?.status === 'healthy' || result.data?.status === 'degraded'),\n    };\n\n    return result;\n  }\n\n  /**\n   * Check if Strands service is healthy and ready for requests\n   * Uses cached result if available and recent\n   */\n  async isServiceHealthy(): Promise<boolean> {\n    // Use cached result if available and recent\n    if (\n      this.lastHealthCheck &&\n      Date.now() - this.lastHealthCheck.timestamp < this.healthCheckCacheMs\n    ) {\n      return this.lastHealthCheck.healthy;\n    }\n\n    try {\n      const result = await this.healthCheck();\n      return (\n        result.success && (result.data?.status === 'healthy' || result.data?.status === 'degraded')\n      );\n    } catch (_error) {\n      // Update cache with failure\n      this.lastHealthCheck = {\n        timestamp: Date.now(),\n        healthy: false,\n      };\n      return false;\n    }\n  }\n\n  /**\n   * Wait for service to become healthy with timeout\n   */\n  async waitForService(timeoutMs: number = 30000): Promise<boolean> {\n    const startTime = Date.now();\n    const checkInterval = 2000; // Check every 2 seconds\n\n    while (Date.now() - startTime < timeoutMs) {\n      if (await this.isServiceHealthy()) {\n        return true;\n      }\n      await new Promise((resolve) => setTimeout(resolve, checkInterval));\n    }\n    return false;\n  }\n\n  /**\n   * Get detailed service status including all health checks\n   */\n  async getServiceStatus(): Promise<{\n    healthy: boolean;\n    baseUrl: string;\n    status?: string;\n    version?: string;\n    checks?: Record<string, string>;\n    lastChecked?: number;\n    error?: string;\n  }> {\n    try {\n      const result = await this.healthCheck();\n\n      return {\n        healthy:\n          result.success &&\n          (result.data?.status === 'healthy' || result.data?.status === 'degraded'),\n        baseUrl: this.baseUrl,\n        status: result.data?.status,\n        version: result.data?.version,\n        checks: result.data?.checks,\n        lastChecked: Date.now(),\n        error: result.success ? undefined : result.error,\n      };\n    } catch (error) {\n      return {\n        healthy: false,\n        baseUrl: this.baseUrl,\n        lastChecked: Date.now(),\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n  }\n}\n\n/**\n * Smart API client factory that routes requests appropriately\n * \n * SECURITY: In browser context, always use same-origin (window.location.origin)\n * to route requests through Next.js API routes. This avoids CORS issues and\n * keeps the backend URL private. The Next.js server-side routes will proxy\n * to the real backend.\n */\nfunction createAIRouterClient() {\n  // In browser context, always use same-origin to avoid CORS\n  // Requests go through Next.js API routes which proxy to backend\n  if (typeof window !== 'undefined') {\n    return new AIRouterClient(window.location.origin);\n  }\n\n  // Server-side: use the configured backend URL\n  // Import configuration dynamically to avoid circular dependencies\n  let config;\n  try {\n    const configModule = require('@/config/api-config');\n    config = configModule.apiConfiguration;\n  } catch (_error) {\n    // Fallback configuration if api-config is not available\n    const baseUrl = apiConfig.useMockApis ? 'http://localhost:3000' : apiConfig.strandsBaseUrl;\n\n    config = {\n      baseUrl,\n      useMock: apiConfig.useMockApis,\n    };\n  }\n\n  return new AIRouterClient(config.baseUrl);\n}\n\n/**\n * Create a Strands API client with explicit configuration\n * Useful for testing or specific deployment scenarios\n */\nexport function createAIRouterClientWithConfig(baseUrl: string, _useMock: boolean = false) {\n  return new AIRouterClient(baseUrl);\n}\n\n/**\n * Default Strands API client instance\n * Automatically switches between real and mock APIs based on environment\n */\nexport const aiRouterClient = createAIRouterClient();\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1510, "column": 0}, "map": {"version":3,"sources":["file:///Users/afos/Downloads/CtrlCheck-af-nonopen/proposal-prepper-services/src/ai-router-integration.ts"],"sourcesContent":["// SPDX-License-Identifier: AGPL-3.0-or-later\n// SPDX-FileCopyrightText: 2025 Seventeen Sierra LLC\n\n/**\n * AI Router Integration\n *\n * Provides high-level integration utilities for the AI routing service.s utilities for managing the integration between the web service\n * and the Strands service, including health monitoring, service discovery,\n * and error recovery.\n */\n\nimport { apiConfigManager } from '@/config/api-config';\nimport { AIRouterClient, aiRouterClient } from './ai-router-client';\n\n/**\n * Service integration status\n */\nexport interface ServiceIntegrationStatus {\n  connected: boolean;\n  healthy: boolean;\n  baseUrl: string;\n  lastChecked: number;\n  error?: string;\n  checks?: Record<string, string>;\n  version?: string;\n}\n\n/**\n * Service integration manager\n */\nexport class AIRouterIntegration {\n  private client: AIRouterClient;\n  private status: ServiceIntegrationStatus | null = null;\n  private statusListeners: Set<(status: ServiceIntegrationStatus) => void> = new Set();\n  private healthCheckInterval: NodeJS.Timeout | null = null;\n  private healthCheckIntervalMs = 30000; // 30 seconds\n\n  constructor(client: AIRouterClient = aiRouterClient) {\n    this.client = client;\n\n    // Listen for configuration changes\n    apiConfigManager.subscribe((config) => {\n      // Assuming AIRouterClient can be re-instantiated with a new base URL if needed\n      // Or, if it's a singleton, its internal config might need updating.\n      // For now, we'll assume it's re-instantiated if the config changes.\n      // This part of the original code was specific to StrandsApiClient and its baseUrl.\n      // If AIRouterClient doesn't have a baseUrl in the same way, this might need adjustment.\n      // Sticking to the provided diff, which doesn't explicitly change this line.\n      // However, the original `this.client = new StrandsApiClient(config.baseUrl);`\n      // implies `AIRouterClient` should also be able to take a `baseUrl`.\n      // Given the diff only changes the constructor signature, I'll keep the subscription logic as is,\n      // but it might be a logical inconsistency if AIRouterClient doesn't use baseUrl.\n      // For now, I'll assume `AIRouterClient` can be constructed with `config.baseUrl` if needed,\n      // or that `aiRouterClient` itself handles config updates.\n      // The diff does not explicitly change the body of the constructor beyond the signature.\n      // So, the original body remains, but `StrandsApiClient` becomes `AIRouterClient`.\n      this.client = new AIRouterClient(config.baseUrl); // Assuming AIRouterClient constructor takes baseUrl\n      this.checkServiceHealth();\n    });\n  }\n\n  /**\n   * Get the current Strands API client\n   */\n  getClient(): AIRouterClient {\n    return this.client;\n  }\n\n  /**\n   * Get current service integration status\n   */\n  getStatus(): ServiceIntegrationStatus | null {\n    return this.status;\n  }\n\n  /**\n   * Check service health and update status\n   */\n  async checkServiceHealth(): Promise<ServiceIntegrationStatus> {\n    try {\n      // Use getServiceStatus which exists on AIRouterClient\n      const serviceStatus = await this.client.getServiceStatus();\n\n      this.status = {\n        connected: true,\n        healthy: serviceStatus.healthy,\n        baseUrl: serviceStatus.baseUrl, // Assuming health status includes baseUrl\n        lastChecked: Date.now(),\n        error: serviceStatus.error,\n        checks: serviceStatus.checks,\n        version: serviceStatus.version,\n      };\n    } catch (error) {\n      this.status = {\n        connected: false,\n        healthy: false,\n        baseUrl: this.client.getBaseUrl(), // Assuming AIRouterClient has getBaseUrl\n        lastChecked: Date.now(),\n        error: error instanceof Error ? error.message : 'Unknown error',\n      };\n    }\n\n    // Notify listeners\n    this.notifyStatusListeners();\n    return this.status;\n  }\n\n  /**\n   * Start periodic health monitoring\n   */\n  startHealthMonitoring(): void {\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n    }\n\n    // Initial check\n    this.checkServiceHealth();\n\n    // Periodic checks\n    this.healthCheckInterval = setInterval(() => {\n      this.checkServiceHealth();\n    }, this.healthCheckIntervalMs);\n  }\n\n  /**\n   * Stop periodic health monitoring\n   */\n  stopHealthMonitoring(): void {\n    if (this.healthCheckInterval) {\n      clearInterval(this.healthCheckInterval);\n      this.healthCheckInterval = null;\n    }\n  }\n\n  /**\n   * Subscribe to status changes\n   */\n  subscribeToStatus(listener: (status: ServiceIntegrationStatus) => void): () => void {\n    this.statusListeners.add(listener);\n\n    // Send current status immediately if available\n    if (this.status) {\n      listener(this.status);\n    }\n\n    return () => this.statusListeners.delete(listener);\n  }\n\n  /**\n   * Notify all status listeners\n   */\n  private notifyStatusListeners(): void {\n    if (this.status) {\n      this.statusListeners.forEach((listener) => listener(this.status!));\n    }\n  }\n\n  /**\n   * Wait for service to become available\n   */\n  async waitForService(timeoutMs: number = 60000): Promise<boolean> {\n    const startTime = Date.now();\n\n    while (Date.now() - startTime < timeoutMs) {\n      await this.checkServiceHealth();\n\n      if (this.status?.healthy) {\n        return true;\n      }\n\n      // Wait before next check\n      await new Promise((resolve) => setTimeout(resolve, 2000));\n    }\n\n    return false;\n  }\n\n  /**\n   * Attempt to recover service connection\n   */\n  async recoverConnection(): Promise<boolean> {\n    // Try different base URLs if the current one fails\n    const fallbackUrls = [\n      'http://strands:8080', // Docker container name\n      'http://localhost:8080', // Local development\n      'http://127.0.0.1:8080', // Alternative localhost\n    ];\n\n    for (const url of fallbackUrls) {\n      try {\n        const testClient = new AIRouterClient(url);\n        const healthy = await testClient.isServiceHealthy();\n\n        if (healthy) {\n          // Update configuration to use this URL\n          apiConfigManager.updateConfiguration({ baseUrl: url });\n          await this.checkServiceHealth();\n          return true;\n        }\n      } catch (_error) { }\n    }\n\n    return false;\n  }\n\n  /**\n   * Get service readiness for operations\n   */\n  isReadyForOperations(): boolean {\n    return this.status?.healthy === true;\n  }\n\n  /**\n   * Get human-readable status message\n   */\n  getStatusMessage(): string {\n    if (!this.status) {\n      return 'Service status unknown';\n    }\n\n    if (this.status.healthy) {\n      return `Service healthy (${this.status.version || 'unknown version'})`;\n    }\n\n    if (this.status.connected) {\n      return `Service connected but unhealthy: ${this.status.error || 'Unknown issue'}`;\n    }\n\n    return `Service unavailable: ${this.status.error || 'Cannot connect'}`;\n  }\n}\n\n/**\n * Global service integration manager instance\n */\nexport const aiRouterIntegration = new AIRouterIntegration();\n\n/**\n * Utility functions for service integration\n */\nexport const AIRouterIntegrationUtils = {\n  /**\n   * Initialize service integration for the application\n   */\n  async initialize(): Promise<void> {\n    aiRouterIntegration.startHealthMonitoring();\n\n    // Wait for initial health check\n    await aiRouterIntegration.checkServiceHealth();\n  },\n\n  /**\n   * Cleanup service integration\n   */\n  cleanup(): void {\n    aiRouterIntegration.stopHealthMonitoring();\n  },\n\n  /**\n   * Check if service is ready and show user-friendly error if not\n   */\n  async ensureServiceReady(): Promise<{ ready: boolean; message?: string }> {\n    const status = await aiRouterIntegration.checkServiceHealth();\n\n    if (status.healthy) {\n      return { ready: true };\n    }\n\n    let message = 'The analysis service is currently unavailable.';\n\n    if (!status.connected) {\n      message += ' Please ensure the AI Router service is running.';\n    } else if (status.error) {\n      message += ` Error: ${status.error}`;\n    }\n\n    return { ready: false, message };\n  },\n\n  /**\n   * Get current service configuration\n   */\n  getServiceConfig(): { baseUrl: string; healthy: boolean; version?: string } {\n    const status = aiRouterIntegration.getStatus();\n    const client = aiRouterIntegration.getClient();\n\n    return {\n      baseUrl: client.getBaseUrl(),\n      healthy: status?.healthy || false,\n      version: status?.version,\n    };\n  },\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1743, "column": 0}, "map": {"version":3,"sources":["file:///Users/afos/Downloads/CtrlCheck-af-nonopen/proposal-prepper-middleware/src/ai-router-adapter.ts"],"sourcesContent":["/*\n * SPDX-License-Identifier: AGPL-3.0-or-later\n * SPDX-FileCopyrightText: 2025 Seventeen Sierra LLC\n */\n\nimport { type NextRequest, NextResponse } from 'next/server';\nimport { mockApiServer } from '@/services/mock-api-server';\nimport type { ApiResponse } from '@/services/ai-router-client';\nimport { aiRouterClient } from '@/services/ai-router-client';\nimport { aiRouterIntegration } from '@/services/ai-router-integration';\n\n/**\n * Utility to extract file from Next.js FormData\n */\nasync function extractFileFromRequest(request: NextRequest): Promise<File | null> {\n  try {\n    const formData = await request.formData();\n    const file = formData.get('file') as File;\n    return file || null;\n  } catch (error) {\n    console.error('Error extracting file from request:', error);\n    return null;\n  }\n}\n\n/**\n * Utility to extract JSON body from Next.js request\n */\nasync function extractJsonFromRequest<T = any>(request: NextRequest): Promise<T | null> {\n  try {\n    const body = await request.json();\n    return body as T;\n  } catch (error) {\n    console.error('Error extracting JSON from request:', error);\n    return null;\n  }\n}\n\n/**\n * Convert API response to Next.js response\n */\nfunction toNextResponse<T>(apiResponse: ApiResponse<T>, successStatus = 200): NextResponse {\n  if (apiResponse.success) {\n    return NextResponse.json(\n      {\n        success: true,\n        data: apiResponse.data,\n      },\n      { status: successStatus }\n    );\n  } else {\n    // Map error codes to HTTP status codes\n    let status = 500;\n    switch (apiResponse.code) {\n      case 'MISSING_FILE':\n      case 'MISSING_PROPOSAL_ID':\n      case 'MISSING_SESSION_ID':\n      case 'MISSING_ISSUE_ID':\n      case 'INVALID_FILE_TYPE':\n      case 'FILE_TOO_LARGE':\n      case 'VALIDATION_FAILED':\n        status = 400;\n        break;\n      case 'SERVICE_UNAVAILABLE':\n        status = 503;\n        break;\n      default:\n        status = 500;\n        break;\n    }\n    return NextResponse.json(\n      { success: false, error: apiResponse.error, code: apiResponse.code },\n      { status }\n    );\n  }\n}\n\n/**\n * Check if AI Router service is available\n * Includes logic to prevent self-recursion loop when running locally\n */\nasync function isServiceAvailable(): Promise<boolean> {\n  try {\n    const baseUrl = aiRouterClient.getBaseUrl();\n    // If client points to localhost:3000 (Next.js default), we are self-referencing in dev mode.\n    // In this case, use mock to avoid recursion.\n    if (baseUrl.includes('localhost:3000')) {\n      console.log('[Adapter] Detected localhost loop (port 3000). Forcing use of MockApiServer.');\n      return false;\n    }\n\n    const healthCheck = await aiRouterClient.healthCheck();\n    return (\n      healthCheck.success &&\n      (healthCheck.data?.status === 'healthy' || healthCheck.data?.status === 'degraded')\n    );\n  } catch (error) {\n    console.warn('[Adapter] AI Router service check failed:', error);\n    return false;\n  }\n}\n\nexport class AIRouterHandlers {\n\n  /**\n   * Handle document upload\n   */\n  static async handleDocumentUpload(request: NextRequest): Promise<NextResponse> {\n    const file = await extractFileFromRequest(request);\n\n    if (!file) {\n      return NextResponse.json(\n        { success: false, error: 'No file provided', code: 'MISSING_FILE' },\n        { status: 400 }\n      );\n    }\n\n    console.log(`[Adapter] Processing upload for file: ${file.name}`);\n\n    try {\n      const available = await isServiceAvailable();\n\n      if (available) {\n        console.log('[Adapter] Using REAL AI Router service for upload');\n        const uploadResult = await aiRouterClient.uploadDocument(file);\n\n        if (uploadResult.success && uploadResult.data) {\n          // If we wanted to auto-start analysis here, we could. \n          // BUT the AgentInterface calls startAnalysis separately.\n          // Let's just return the upload result to keep it simple and clean.\n          // Wait, the previous code auto-started analysis. Let's see if that's required.\n          // AgentInterface calls `uploadService.uploadDocument` which calls this endpoint.\n          // Then it calls `analysisService.startAnalysis` separately.\n          // So `handleDocumentUpload` SHOULD NOT auto-start analysis ideally, unless we want to optimize.\n          // However, let's stick to what allows `proposalId` to be returned.\n          return toNextResponse(uploadResult, 201);\n        }\n        throw new Error(uploadResult.error || 'Upload failed');\n      }\n\n      // Fallback to Mock\n      console.log('[Adapter] Using MOCK AI Router service for upload');\n      const result = await mockApiServer.handleDocumentUpload(file);\n      return toNextResponse(result, 201);\n\n    } catch (error) {\n      console.error('[Adapter] Upload error:', error);\n      // Final Fallback Attempt\n      try {\n        const fallbackResult = await mockApiServer.handleDocumentUpload(file);\n        return toNextResponse(fallbackResult, 201);\n      } catch (e) {\n        return NextResponse.json(\n          { success: false, error: 'Upload failed completely', code: 'UPLOAD_FAILED' },\n          { status: 500 }\n        );\n      }\n    }\n  }\n\n  /**\n   * Handle analysis start\n   */\n  static async handleAnalysisStart(request: NextRequest): Promise<NextResponse> {\n    const body = await extractJsonFromRequest<{\n      proposalId?: string;\n      proposal_id?: string;\n      documentId?: string;\n      document_id?: string;\n      filename?: string;\n    }>(request);\n\n    console.log('[Adapter] Analysis Start Request Body:', JSON.stringify(body));\n\n    const proposalId = body?.proposalId || body?.proposal_id;\n    const documentId = body?.documentId || body?.document_id;\n    const filename = body?.filename;\n\n    if (!proposalId) {\n      console.error('[Adapter] Missing proposalId');\n      return NextResponse.json(\n        { success: false, error: 'Proposal ID is required', code: 'MISSING_PROPOSAL_ID' },\n        { status: 400 }\n      );\n    }\n\n    try {\n      const available = await isServiceAvailable();\n\n      if (available) {\n        console.log('[Adapter] Using REAL AI Router service for analysis start');\n        const result = await aiRouterClient.startAnalysis(proposalId, documentId, filename);\n        return toNextResponse(result, 201);\n      }\n\n      console.log('[Adapter] Using MOCK AI Router service for analysis start');\n      const result = await mockApiServer.handleAnalysisStart(proposalId);\n      return toNextResponse(result, 201);\n\n    } catch (error) {\n      console.error('[Adapter] Analysis start error:', error);\n      // Fallback\n      try {\n        const result = await mockApiServer.handleAnalysisStart(proposalId);\n        return toNextResponse(result, 201);\n      } catch (e) {\n        return NextResponse.json(\n          { success: false, error: 'Analysis start failed', code: 'ANALYSIS_START_FAILED' },\n          { status: 500 }\n        );\n      }\n    }\n  }\n\n  /**\n   * Handle analysis results\n   */\n  static async handleAnalysisResults(\n    _request: NextRequest,\n    { params }: { params: Promise<{ sessionId: string }> }\n  ): Promise<NextResponse> {\n    const { sessionId } = await params;\n    if (!sessionId) {\n      return NextResponse.json(\n        { success: false, error: 'Session ID is required', code: 'MISSING_SESSION_ID' },\n        { status: 400 }\n      );\n    }\n\n    try {\n      if (await isServiceAvailable()) {\n        const result = await aiRouterClient.getResults(sessionId);\n        return toNextResponse(result);\n      }\n      const result = await mockApiServer.handleAnalysisResults(sessionId);\n      return toNextResponse(result);\n    } catch (error) {\n      // Fallback\n      try {\n        const res = await mockApiServer.handleAnalysisResults(sessionId);\n        return toNextResponse(res);\n      } catch (e) {\n        return NextResponse.json(\n          { success: false, error: 'Results failed', code: 'RESULTS_RETRIEVAL_FAILED' },\n          { status: 500 }\n        );\n      }\n    }\n  }\n\n  /**\n   * Handle analysis status\n   */\n  static async handleAnalysisStatus(\n    _request: NextRequest,\n    { params }: { params: Promise<{ sessionId: string }> }\n  ): Promise<NextResponse> {\n    const { sessionId } = await params;\n    if (!sessionId) {\n      return NextResponse.json(\n        { success: false, error: 'Session ID is required', code: 'MISSING_SESSION_ID' },\n        { status: 400 }\n      );\n    }\n\n    try {\n      if (await isServiceAvailable()) {\n        const result = await aiRouterClient.getAnalysisStatus(sessionId);\n        return toNextResponse(result);\n      }\n      const result = await mockApiServer.handleAnalysisStatus(sessionId);\n      return toNextResponse(result);\n    } catch (error) {\n      try {\n        const res = await mockApiServer.handleAnalysisStatus(sessionId);\n        return toNextResponse(res);\n      } catch (e) {\n        return NextResponse.json(\n          { success: false, error: 'Status failed', code: 'ANALYSIS_STATUS_FAILED' },\n          { status: 500 }\n        );\n      }\n    }\n  }\n\n  /**\n   * Health Check\n   */\n  static async handleHealthCheck(_request: NextRequest): Promise<NextResponse> {\n    const webHealth = await mockApiServer.handleHealthCheck();\n    const available = await isServiceAvailable();\n    let serviceHealth = null;\n    if (available) {\n      const res = await aiRouterClient.healthCheck();\n      serviceHealth = res.data;\n    }\n    return NextResponse.json({\n      success: true,\n      data: {\n        web_service: webHealth.data,\n        ai_router_service: serviceHealth || { status: 'unavailable' },\n        integration_status: available ? 'connected' : 'fallback_mode',\n        timestamp: new Date().toISOString(),\n      }\n    });\n  }\n\n  static async handleServiceStatus(_req: Request) {\n    const status = aiRouterIntegration.getStatus();\n    if (!status) await aiRouterIntegration.checkServiceHealth();\n    const current = aiRouterIntegration.getStatus();\n\n    if (!current) return NextResponse.json({ success: false, error: 'Service unavailable' }, { status: 503 });\n\n    return NextResponse.json({\n      success: true,\n      data: {\n        healthy: current.healthy,\n        status: current.error ? 'degraded' : 'healthy',\n        version: current.version,\n        checks: current.checks,\n        baseUrl: current.baseUrl\n      }\n    });\n  }\n}\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2057, "column": 0}, "map": {"version":3,"sources":["file:///Users/afos/Downloads/CtrlCheck-af-nonopen/proposal-prepper-web/src/app/api/documents/upload/route.ts"],"sourcesContent":["/*\n * SPDX-License-Identifier: AGPL-3.0-or-later\n * SPDX-FileCopyrightText: 2025 Seventeen Sierra LLC\n */\n\n/**\n * Next.js API Route for Document Upload\n *\n * This route now uses the Strands integration adapter for end-to-end workflow.\n * Connects to real Strands service with fallback to mock for development.\n */\n\nimport { AIRouterHandlers } from 'proposal-prepper-middleware/ai-router-adapter';\n\n// Export the handler from the AI Router integration adapter\nimport { NextRequest, NextResponse } from 'next/server';\n\nexport async function POST(req: NextRequest) {\n    return AIRouterHandlers.handleDocumentUpload(req as any);\n}\n"],"names":[],"mappings":"AAAA;;;CAGC,GAED;;;;;CAKC;;;;AAED;;AAKO,eAAe,KAAK,GAAgB;IACvC,OAAO,yLAAgB,CAAC,oBAAoB,CAAC;AACjD"}}]
}